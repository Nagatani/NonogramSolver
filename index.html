<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ピクロスソルバー</title>
    <style>
        /* --- General Styles --- */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #f3f4f6;
            margin: 0;
            padding: 1rem;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
        }

        .container {
            width: 100%;
            max-width: 900px;
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            padding: 1.5rem;
            box-sizing: border-box;
        }

        header {
            text-align: center;
            margin-bottom: 1.5rem;
        }

        h1 {
            font-size: 1.875rem;
            font-weight: bold;
            color: #1f2937;
            margin: 0 0 0.5rem 0;
        }

        header p {
            color: #4b5563;
            margin: 0;
        }
        
        /* --- Controls Area --- */
        .controls-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            background-color: #f9fafb;
            padding: 1rem;
            border-radius: 0.5rem;
            margin-bottom: 1.5rem;
        }
        
        .size-controls, .action-buttons {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex-wrap: wrap;
        }
        
        .action-buttons {
             justify-content: flex-end;
        }

        .controls-area label {
            font-weight: 500;
            color: #374151;
        }

        .controls-area input[type="number"] {
            width: 4rem;
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            box-shadow: inset 0 1px 2px 0 rgba(0,0,0,0.05);
        }

        button {
            padding: 0.6rem 1.2rem;
            font-weight: 600;
            color: white;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 1px 3px 0 rgba(0,0,0,0.1), 0 1px 2px 0 rgba(0,0,0,0.06);
        }
        
        button:hover {
            transform: scale(1.05);
        }
        
        button:disabled {
            background-color: #9ca3af;
            cursor: wait;
            transform: none;
        }

        .solve-button { background-color: #4f46e5; }
        .solve-button:hover:not(:disabled) { background-color: #4338ca; }
        
        .reset-button { background-color: #ef4444; }
        .reset-button:hover:not(:disabled) { background-color: #dc2626; }

        /* --- Picross Grid Area --- */
        .picross-wrapper {
            width: 100%;
            overflow-x: auto;
        }
        .picross-container {
            display: inline-grid;
            grid-template-areas:
                "corner col-rules"
                "row-rules grid";
            grid-template-columns: auto 1fr;
            grid-template-rows: auto 1fr;
            gap: 4px;
            padding: 1rem;
            background-color: #e5e7eb;
            border-radius: 0.5rem;
        }
        
        #col-rules-container { grid-area: col-rules; }
        #row-rules-container { grid-area: row-rules; }
        #grid-container { grid-area: grid; }

        .rules-container {
            display: grid;
            gap: 1px;
        }
        #col-rules-container {
            padding-bottom: 2px;
            border-bottom: 2px solid #4b5563;
        }
        #row-rules-container {
            padding-right: 2px;
            border-right: 2px solid #4b5563;
        }
        .rule-input-wrapper {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .rule-input {
            width: 100%;
            height: 100%;
            min-height: 32px;
            min-width: 32px;
            box-sizing: border-box;
            border: none;
            background-color: #f9fafb;
            text-align: center;
            font-size: 0.9rem;
        }
        #col-rules-container .rule-input {
            writing-mode: vertical-rl;
            text-orientation: mixed;
            line-height: 32px;
        }
         #row-rules-container .rule-input {
            text-align: right;
            padding-right: 0.5rem;
        }
        
        #grid-container {
            display: grid;
            gap: 1px;
            background-color: #9ca3af;
            border: 2px solid #1f2937;
        }
        
        .cell {
            width: 100%;
            height: 0;
            padding-bottom: 100%; /* Aspect ratio 1:1 */
            position: relative;
            background-color: white;
            transition: background-color 0.2s;
            border: none;
        }
        .cell:hover {
            background-color: #e5e7eb;
        }
        .cell.filled {
            background-color: #1f2937;
        }
        .cell.crossed .cross-icon {
            display: block;
        }
        .cross-icon {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            color: #6b7280;
        }

        /* --- Message Area --- */
        #message-area {
            text-align: center;
            margin-top: 1.5rem;
            padding: 0.75rem;
            border-radius: 0.375rem;
            border-width: 1px;
            border-style: solid;
            display: none; /* Hidden by default */
        }
        #message-area.info {
            background-color: #eff6ff;
            color: #1d4ed8;
            border-color: #bfdbfe;
        }
        #message-area.error {
            background-color: #fef2f2;
            color: #b91c1c;
            border-color: #fecaca;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .controls-area {
                grid-template-columns: 1fr;
            }
            .action-buttons {
                justify-content: center;
            }
            .container {
                padding: 1rem;
            }
             h1 { font-size: 1.5rem; }
        }
    </style>
</head>
<body>

    <div class="container">
        <header>
            <h1>ピクロスソルバー</h1>
            <p>ルールと盤面の状態から、確定できるマスを導き出します。</p>
        </header>

        <div class="controls-area">
            <div class="size-controls">
                <label for="rows-input">サイズ:</label>
                <input type="number" id="rows-input" value="5" min="1" max="20">
                <span class="text-gray-500">x</span>
                <input type="number" id="cols-input" value="5" min="1" max="20">
            </div>
            <div class="action-buttons">
                <button id="solve-button" class="solve-button">確定マスを探す</button>
                <button id="reset-button" class="reset-button">リセット</button>
            </div>
        </div>
        
        <div class="picross-wrapper">
            <div class="picross-container">
                <div id="col-rules-container" class="rules-container"></div>
                <div id="row-rules-container" class="rules-container"></div>
                <div id="grid-container"></div>
            </div>
        </div>

        <div id="message-area"></div>
    </div>

    <script>
        const CELL_STATE = {
            EMPTY: 0,
            FILLED: 1,
            CROSSED: 2,
        };
        const MAX_SIZE = 20;

        let state = {
            rows: 5,
            cols: 5,
            rowRules: Array(5).fill([]),
            colRules: Array(5).fill([]),
            grid: Array(5).fill(null).map(() => Array(5).fill(CELL_STATE.EMPTY)),
            isSolving: false,
        };

        const possibilitiesCache = new Map();

        // --- Core Logic Functions ---
        const generatePossibilities = (size, rule) => {
            const effectiveRule = (rule.length === 0 || rule.every(r => r === 0)) ? [0] : rule;
            const cacheKey = `${size}-${JSON.stringify(effectiveRule)}`;
            if (possibilitiesCache.has(cacheKey)) {
                return possibilitiesCache.get(cacheKey);
            }

            if (effectiveRule.length === 1 && effectiveRule[0] === 0) {
                const result = [new Array(size).fill(0)];
                possibilitiesCache.set(cacheKey, result);
                return result;
            }

            const solutions = [];
            function recurse(blockIndex, startIndex, currentArrangement) {
                if (blockIndex === effectiveRule.length) {
                    solutions.push(currentArrangement);
                    return;
                }
                const blockLength = effectiveRule[blockIndex];
                let spaceForRemaining = 0;
                for (let i = blockIndex + 1; i < effectiveRule.length; i++) {
                    spaceForRemaining += effectiveRule[i] + 1;
                }
                const latestStart = size - spaceForRemaining - blockLength;

                for (let i = startIndex; i <= latestStart; i++) {
                    const newArrangement = [...currentArrangement];
                    for (let j = 0; j < blockLength; j++) {
                        newArrangement[i + j] = 1;
                    }
                    recurse(blockIndex + 1, i + blockLength + 1, newArrangement);
                }
            }

            recurse(0, 0, new Array(size).fill(0));
            possibilitiesCache.set(cacheKey, solutions);
            return solutions;
        };

        const solveLine = (lineSize, rule, userLine) => {
            const allPossibilities = generatePossibilities(lineSize, rule);
            const validPossibilities = allPossibilities.filter(p => {
                for (let i = 0; i < lineSize; i++) {
                    if (userLine[i] === CELL_STATE.FILLED && p[i] === 0) return false;
                    if (userLine[i] === CELL_STATE.CROSSED && p[i] === 1) return false;
                }
                return true;
            });
            if (validPossibilities.length === 0) {
                if (rule.reduce((a, b) => a + b, 0) + rule.length - 1 > lineSize) {
                    return { error: "ルールが行/列のサイズを超えています。" };
                }
                return { error: "入力に矛盾があります。" };
            }
            const newLine = [...userLine];
            for (let i = 0; i < lineSize; i++) {
                if (newLine[i] !== CELL_STATE.EMPTY) continue;
                const firstState = validPossibilities[0][i];
                const allAgree = validPossibilities.every(p => p[i] === firstState);
                if (allAgree) {
                    newLine[i] = firstState === 1 ? CELL_STATE.FILLED : CELL_STATE.CROSSED;
                }
            }
            return { updatedLine: newLine };
        };

        const transposeGrid = (grid) => {
            if (!grid || grid.length === 0) return [];
            return grid[0].map((_, colIndex) => grid.map(row => row[colIndex]));
        };
        
        const deepEqual = (a, b) => JSON.stringify(a) === JSON.stringify(b);

        // --- UI Rendering Functions ---
        function render() {
            renderRules();
            renderGrid();
        }

        function renderRules() {
            const rowRulesContainer = document.getElementById('row-rules-container');
            const colRulesContainer = document.getElementById('col-rules-container');
            rowRulesContainer.innerHTML = '';
            colRulesContainer.innerHTML = '';
            rowRulesContainer.style.gridTemplateRows = `repeat(${state.rows}, minmax(32px, 1fr))`;
            colRulesContainer.style.gridTemplateColumns = `repeat(${state.cols}, minmax(32px, 1fr))`;

            for (let i = 0; i < state.rows; i++) {
                const wrapper = document.createElement('div');
                wrapper.className = 'rule-input-wrapper';
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'rule-input';
                input.dataset.index = i;
                input.dataset.type = 'row';
                input.value = state.rowRules[i].join(' ');
                wrapper.appendChild(input);
                rowRulesContainer.appendChild(wrapper);
            }

            for (let i = 0; i < state.cols; i++) {
                const wrapper = document.createElement('div');
                wrapper.className = 'rule-input-wrapper';
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'rule-input';
                input.dataset.index = i;
                input.dataset.type = 'col';
                input.value = state.colRules[i].join(' ');
                wrapper.appendChild(input);
                colRulesContainer.appendChild(wrapper);
            }
        }

        function renderGrid() {
            const gridContainer = document.getElementById('grid-container');
            gridContainer.innerHTML = '';
            gridContainer.style.gridTemplateColumns = `repeat(${state.cols}, 1fr)`;
            gridContainer.style.gridTemplateRows = `repeat(${state.rows}, 1fr)`;

            for (let r = 0; r < state.rows; r++) {
                for (let c = 0; c < state.cols; c++) {
                    const cell = document.createElement('button');
                    cell.className = 'cell';
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    
                    const cellState = state.grid[r][c];
                    if (cellState === CELL_STATE.FILLED) {
                        cell.classList.add('filled');
                    } else if (cellState === CELL_STATE.CROSSED) {
                        cell.classList.add('crossed');
                        const svgNS = "http://www.w3.org/2000/svg";
                        const svg = document.createElementNS(svgNS, "svg");
                        svg.setAttribute("class", "cross-icon");
                        svg.setAttribute("viewBox", "0 0 24 24");
                        const line1 = document.createElementNS(svgNS, "line");
                        line1.setAttribute("x1", "18"); line1.setAttribute("y1", "6"); line1.setAttribute("x2", "6"); line1.setAttribute("y2", "18");
                        const line2 = document.createElementNS(svgNS, "line");
                        line2.setAttribute("x1", "6"); line2.setAttribute("y1", "6"); line2.setAttribute("x2", "18"); line2.setAttribute("y2", "18");
                        [line1, line2].forEach(l => {
                            l.setAttribute("stroke", "currentColor"); l.setAttribute("stroke-width", "2.5");
                            l.setAttribute("stroke-linecap", "round"); l.setAttribute("stroke-linejoin", "round");
                        });
                        svg.appendChild(line1);
                        svg.appendChild(line2);
                        cell.appendChild(svg);
                    }
                    gridContainer.appendChild(cell);
                }
            }
        }
        
        function showMessage(text, type = 'info') {
            const msgArea = document.getElementById('message-area');
            msgArea.textContent = text;
            msgArea.className = type;
            msgArea.style.display = 'block';
        }

        function hideMessage() {
            document.getElementById('message-area').style.display = 'none';
        }

        // --- Event Handlers ---
        function handleSizeChange() {
            const rowsInput = document.getElementById('rows-input');
            const colsInput = document.getElementById('cols-input');
            const newRows = Math.max(1, Math.min(MAX_SIZE, parseInt(rowsInput.value, 10) || 1));
            const newCols = Math.max(1, Math.min(MAX_SIZE, parseInt(colsInput.value, 10) || 1));
            rowsInput.value = newRows;
            colsInput.value = newCols;

            state = {
                rows: newRows,
                cols: newCols,
                rowRules: Array(newRows).fill([]),
                colRules: Array(newCols).fill([]),
                grid: Array(newRows).fill(null).map(() => Array(newCols).fill(CELL_STATE.EMPTY)),
                isSolving: false,
            };
            possibilitiesCache.clear();
            hideMessage();
            render();
        }

        function handleRuleChange(event) {
            const input = event.target;
            if (!input.classList.contains('rule-input')) return;
            const index = parseInt(input.dataset.index, 10);
            const type = input.dataset.type;
            const parsedRule = input.value.split(/[\s,]+/).filter(n => n).map(Number);
            if(parsedRule.some(isNaN)) {
                showMessage(`ルールには数字を入力してください。`, 'error');
                return;
            }
            if (type === 'row') {
                state.rowRules[index] = parsedRule;
            } else {
                state.colRules[index] = parsedRule;
            }
        }
        
        function handleCellClick(event) {
            const cell = event.target.closest('.cell');
            if (!cell) return;
            const r = parseInt(cell.dataset.row, 10);
            const c = parseInt(cell.dataset.col, 10);
            state.grid[r][c] = (state.grid[r][c] + 1) % 3;
            hideMessage();
            renderGrid();
        }

        function handleSolve() {
            if (state.isSolving) return;
            state.isSolving = true;
            document.getElementById('solve-button').disabled = true;
            document.getElementById('solve-button').textContent = "解析中...";
            showMessage('解析中...');

            setTimeout(() => {
                let currentGrid = state.grid.map(row => [...row]);
                let changed = true;
                let iteration = 0;
                const maxIterations = (state.rows + state.cols) * 2;

                while (changed && iteration < maxIterations) {
                    changed = false;
                    iteration++;
                    
                    // Rows
                    for (let r = 0; r < state.rows; r++) {
                        const result = solveLine(state.cols, state.rowRules[r], currentGrid[r]);
                        if (result.error) {
                            showMessage(`行 ${r + 1}: ${result.error}`, 'error');
                            resetSolveState(); return;
                        }
                        if (!deepEqual(currentGrid[r], result.updatedLine)) {
                            currentGrid[r] = result.updatedLine;
                            changed = true;
                        }
                    }

                    // Cols
                    let transposed = transposeGrid(currentGrid);
                    for (let c = 0; c < state.cols; c++) {
                        const result = solveLine(state.rows, state.colRules[c], transposed[c]);
                        if (result.error) {
                            showMessage(`列 ${c + 1}: ${result.error}`, 'error');
                            resetSolveState(); return;
                        }
                        if (!deepEqual(transposed[c], result.updatedLine)) {
                            transposed[c] = result.updatedLine;
                            changed = true;
                        }
                    }
                    if (changed) currentGrid = transposeGrid(transposed);
                }

                if (iteration >= maxIterations) {
                    showMessage('反復回数が上限に達しました。ロジックが複雑すぎるか、矛盾があるかもしれません。', 'error');
                } else if (deepEqual(state.grid, currentGrid)) {
                    showMessage('これ以上自動で確定できるマスはありません。');
                } else {
                    showMessage('確定できるマスを更新しました。');
                }
                
                state.grid = currentGrid;
                renderGrid();
                resetSolveState();
            }, 50);
        }
        
        function handleReset() {
            state.grid = Array(state.rows).fill(null).map(() => Array(state.cols).fill(CELL_STATE.EMPTY));
            showMessage('盤面をリセットしました。');
            renderGrid();
        }
        
        function resetSolveState() {
             state.isSolving = false;
             const solveButton = document.getElementById('solve-button');
             solveButton.disabled = false;
             solveButton.textContent = "確定マスを探す";
        }

        // --- Initial Setup ---
        window.onload = () => {
            document.getElementById('rows-input').addEventListener('change', handleSizeChange);
            document.getElementById('cols-input').addEventListener('change', handleSizeChange);
            document.getElementById('solve-button').addEventListener('click', handleSolve);
            document.getElementById('reset-button').addEventListener('click', handleReset);
            document.querySelector('.picross-container').addEventListener('change', handleRuleChange);
            document.getElementById('grid-container').addEventListener('click', handleCellClick);
            render();
        };
    </script>
</body>
</html>
